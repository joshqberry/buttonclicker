
Some sites say Arduino 1.0.5 wasn't working with shield, but that 1.0.3 was. Am
currently using 1.6.3. Don't know if that version has known issues. Haven't seen any
sites say that it does. Although you'd have to go back and check if they're talking
about the official Arduino shield or the CC3000.

Might consider adding antenna to boost signal

Heroku add-ons? Can I add on dino or arduino?

OK, some info gathered from Heroku info pages (all bookmarked):

"The Heroku platform automatically routes HTTP requests sent to your app’s hostname(s)
to your web dynos."
"Inbound requests are received by a load balancer that offers SSL termination. From here
they are passed directly to a set of routers. The routers are responsible for
determining the location of your application’s web dynos and forwarding the HTTP
request to one of these dynos. A request’s unobfuscated path from the end-client
through the Heroku infrastructure to your application allows for full support of
HTTP 1.1 features such as chunked responses, long polling, websockets, and using an
async webserver to handle multiple responses from a single web process."

... There's some info on timeouts, not quite sure if it applies for this case, but
you may want to look at it...
... also on response buffering, same thing...
... also for "100-continue", which I don't think I'd need
... Also a whole page on worker dynos, which I don't think I'd need

From this page:
http://en.wikipedia.org/wiki/Push_technology
"For example, BOSH is a popular, long-lived HTTP technique used as a long-polling
alternative to TCP when TCP is difficult or impossible to employ directly (e.g.,
in a web browser); it is also an underlying technology in the XMPP, which Apple
uses for its iCloud push support."

YOU MAY VERY MUCH NEED TO LOOK AT WHAT BOSH HAS TO OFFER!
http://en.wikipedia.org/wiki/BOSH

So here's a typical request that goes to Heroku. This request was made when I
refreshed the page at Heroku. So I guess this is the type of request you'd have
to send to Heroku one way or another. (NOTE: At the very beginning of the request,
there an extra bit, "at=info", but the Heroku info page doesn't indicate that that
is a necessary part of the request.):
  method=GET path="/" host=aqueous-scrubland-2496.herokuapp.com
  request_id=2e89beee-6b43-475e-a05a-f7180cb4762d fwd="75.166.2.229" dyno=web.1
  connect=1ms service=107ms status=200 bytes=2975

"WebSocket functionality is supported for all applications."

...Lots more, too much, on the Dynos page. Leaving it open for now.

Hey, SHOULD I be using
  window.pusher_key = '<%= ENV['heroku_key'] %>';
in my application layout?
Wes sez: you should never give keys to your client, because they can impersonate you.
So any need for a key should involve an ajax call to the server site, which will then
provide the key. Well, not looking at that now.
... huh, looks like taking this out of application layout:
    <script type="text/javascript">
       window.pusher_key = '<%= ENV['heroku_key'] %>';
     </script>
... doesn't affect the button. It's still working. But will it on heroku?

HEY, something you'll want to come back to: You can set some or all of the Arduino pins to
act as pull-up/down resistors. You'll want to do that eventually just to have less pieces
on your board.

HEY ALSO, note that Texas Instruments is already abandoning their promoting of the cc3000,
instead recommending the cc3100 or cc3200. Shitfire. Well, you probably won't worry about
upgrading now, but keep that in mind, I guess.



$('#testleft').click(function(){
  $.get('/testlefty')
});

$('#testright').click(function(){
  $.get('/testrighty')
});



border: 1px solid black;

<!-- <% @queue.push("a") %> -->

<body onload="popup('NextiesDiv')">

<script type="text/javascript">
$(document).ready(function() {
    $("#b").animate({left: "+=500"}, 2000);
    $("#b").animate({left: "-=300"}, 1000);
});

</script

<div style="position:relative">
    <div id="b" style="position:absolute;">B</div>
</div>



<button id="fade">Click to fade in vs</button><br><br>

<script>
$(document).ready(function(){
    $("#fade").click(function(){
        $("#vs").fadeIn();
    });
});
</script>

also display none


function yesnoCheck() {
if (document.getElementById('yesCheck').checked) {
    document.getElementById('ifYes').style.display = 'block';
}
else document.getElementById('ifYes').style.display = 'none';

}



Known issues:
  -- can't keep connection from timing out, requires re-press to wake it up
  -- can't seem to do this with 9V battery, although it was working fine with one button



popup('NextiesDiv');











var firstplayer =  document.getElementById("InWaiting").innerHTML;
document.getElementById("YoureNext").innerHTML = firstplayer;
if (document.getElementById("Player1Nexty").innerHTML === "player 1") {
  document.getElementById("Player1Nexty").innerHTML = player1nexty;
}
else {
document.getElementById("Player3Nexty").innerHTML = player1nexty;
}
if (document.getElementById("Player2Nexty").innerHTML === "player 2") {
  document.getElementById("Player2Nexty").innerHTML = player2nexty;
}
else {
document.getElementById("Player4Nexty").innerHTML = player2nexty;
}
if (document.getElementById("Player1NextyPopup").innerHTML === "player 1") {
document.getElementById("Player1NextyPopup").innerHTML = player1nextyPopup;
}
else {
document.getElementById("Player3NextyPopup").innerHTML = player1nextyPopup;
}
if (document.getElementById("Player2NextyPopup").innerHTML === "player 2") {
document.getElementById("Player2NextyPopup").innerHTML = player2nextyPopup;
}
else {
document.getElementById("Player4NextyPopup").innerHTML = player2nextyPopup;
}
}

Don't think I need the following anymore, but just in case:

function setNexties() {
	var thistry = document.getElementById('hobo').innerHTML;
	document.getElementById('guh').innerHTML = thistry;
}


-------------

JEEZ, THAT'S a good lesson: I was having issues recognizing the inner HTML of divs -- that's
because you had EXTRA SPACES IN THOSE DIVS. Which mattered when I was trying to match a string.
Damn, that was stupid error.

WOW so this doesn't work:
function changeImagejs() {
	document.getElementById('playertwat').value = document.getElementById('guh').innerHTML;
	}
... but this does:
function changeImagejs() {
document.getElementById('guh').innerHTML = document.getElementById('playertwat').value;
	}
... it would behoove me to understand why...

-------------

Thursday 5/28 11:30 a.m.

SO FUCKIN' CLOSE BABY!! OK, so I discovered that Heroku was sending me BACK response
information (nothing more than just headers stuff and a "0"), and what was happening
with double-clicks was that I wasn't allowing all that response stuff to arrive before I
attempted a new request. THAT, I'm pretty sure, was the cause of the freezing. I added
a "while" statement to force the program to wait until the entire response was received,
and now I'm having very good luck with my clicks!!!!!
... AND I'm using Keep-Alive connections, for now, which saves some time.
My current efforts have been saved as HerokuReconnectTestingWithButtons_BETTER.

This... is AWESOME. Now I need to get whatever safety measures in place... and then I
THINK I can actually move on.

As long as the fucking FREEZING issue is behind me, I should be able to implement the
other safety measures without too much issue...

I suppose the really big issue is if the Arduino is not able to detect a lost connection
with Heroku. I NEED it to recognize a dropped connection, so it can start the re-connect
process.

NOTE: I just added bootstrap so I can get a test run of this going.

Know what, I need a way to indicate ALL of this via my app. Not sure how...

-------------

All right, issues:

ARDUINO POWER CUTS OUT
  -- maybe a light that indicates power is on?
  -- maybe ability to turn power on or off?
ARDUINO IS FROZEN
  -- hmm, I suppose I don't know... An ability to reboot? From the code itself?
WIFI CONNECTION INITIALLY DOESN'T CONNECT
  -- Goes to httpRequest, which should identify that connection is not there, and then loop
  back to getConnected
WIFI CONNECTION GOES OUT IN MIDDLE OF USAGE
  -- Well, hopefully my "if (!client.connected)" statement, which is in the main loop,
  should take care of that. Should revert to retryHeroku, which then loops to httpRequest,
  which then would loop back to getConnected
IF WIFI'S OK, BUT NO INITIAL CONNECTION TO HEROKU
  -- The httpRequest should revert to retryHeroku, which then loops to httpRequest, and
  that should continue until a connection is established
  -- although note that this process currently takes about 30 seconds or so.
IF WIFI'S OK, BUT HEROKU CONNECTION GOES OUT IN MIDDLE OF USAGE
  -- Again, hopefully my "if (!client.connected)" statement in the main loop with see that
  I am not connected, and then revert to retryHeroku, and on to httpRequest, and then back
  to retryHeroku, etc.

Doing a little testing with HerokuReconnectTestingWithButtons_BETTER:

  -- Can do at least 15 clicks in a row, either button, no prob. Must pause for Heroku
response to finish. No timeout occurs (which I expected -- Heroku should be restarting my
30-second window for a connection each time a GET request is sent.)
  -- Can let the program sit without any clicks, just looping through the httpRequest
  section as each timeout occurs, and then start clicking after a few loops have gone by,
  and everything is fine. Can then sit out another few loops, and then come back and
  start clicking, and everything is still fine.
  -- Can let program just sit and go through httpRequest loops, at least 10 iterations.
  But the Heroku connection still cuts out somewhere in there. Gotta fix that...
  -- Huh, that's weird: I just restarted, and it went from getConnected to httpRequest
  even though it hadn't obtained the IP address. It's not supposed to call the httpRequest
  unless the IP address has been obtained... Maybe that was something weird to do with
  it staying plugged in even though I restarted (by closing and then reopening the serial
  window).
  -- A double-click doesn't seem to do anything (good). Only one GET request is sent.
  However, holding down the button sends REPEATED GET requests...
  -- Actually, looks like a slightly slower double-click DOES set two GET requests...
  but that shouldn't be too much of a worry. I've only been able to make this happen when
  double-clicking immediately after restarting. After that, double-clicks don't seem to
  do anything...
  -- Note that it doesn't take long (at least currently), after a single click, for another
  single click to send another GET request. About a second.
  -- pressing the buttons at any point during startup doesn't seem to affect anything...

NOTED FREEZES:
  -- One time, it froze after saying "Wifi status: connected." Maybe the client.stop command
  created an issue?
  -- It's not freezing on "Performing HTTP connection to:", but it is stopping there if
 the connection to Heroku has been lost. And that's about a 30-second wait...

Uh, for some reason, it looks like the whole process is starting again from the SETUP if
the wifi is unable to connect. No idea why, but that's pretty awesome.
  -- I saw it restart from SETUP after five unsucessful tries to connect to wifi.
  -- Actually, that probably because the setup is supposed to run getConnected, and so
  if that can't be completed, the setup can't be completed, and so it must just be starting
  over either after a certain time or a certain number of attempts. Cool!

-------------

Wednesday 5/27 7 a.m.

HerokuReconnectTestingwithBUTTONS now works... but there are still issues. I think those
are related to debouncing -- the main issue I notice is a fuck-up if there are two
button-presses too close together -- but this still needs testing.

And dammit, note that if there is a button-press fuck-up, everything FREEZES. The re-connect
doesn't work.

I think ALSO what's happening is if I click the button during the Heroku timeout, then
the whole thing also freezes. Although ONLY during the timeout; if I just click a couple
times, then wait (so as to avoid the timeout) for the disconnect and re-connect, I can keep
going.

About time to give up and just have this fucker re-establish a connection every time a
button is clicked.

OK, maybe, just maybe, using the Keep-Alive means that I'm disconnecting, but actually
re-connecting while Heroku just thinks the connection is still active. Then I'm hitting
the 55 second timeout, and then I click the button, and shit freezes.

Anyway, though, changing to a Close connection is not the answer... or at least not unless
I want to continually reconnect. I HAVE verified that the button-click only works once
with the Close connection.

Dammit, but setting the re-connect to close to 55 seconds doesn't seem to do it either.
Something's up. But I don't know what. HUH well for some reason my serial output just
showed a shitton of button-pushes -- maybe all the ones that didn't work before. Maybe
that's what was freezing it?

Dammit, for some reason, a 30-second re-connect was working, but when I set the re-connect
to 40 seconds, nothing happening! It's not disconnecting! WHA?

Yeah, with 30 seconds, everything seems fine -- as long as I'm not clicking too fast...
But VERFIED, with 40 seconds, it just doesn't disconnect. I just don't get it.

And, weirdly, with 40 seconds, it seems like I can keep on going with button-pushes. But
that can't be the case. The Keep-Alive must be allowing that.

All I can surmise with the 40 seconds is that the client is not longer connected, which
is why the re-connecting command does not get issued.

OK, well, using millis to look at my button pushes, it's clear I have a debounce issue.
Here's from the latest button click:

button pushed
143775
button pushed
143778
button pushed
143782
button pushed
143788
button pushed
143793
button pushed
143798
button pushed
143803
button pushed
143808
button pushed
143813
button pushed
143818
button pushed
143823
button pushed
143828
button pushed
143834
button pushed
143839
button pushed
143844
button pushed
143849
button pushed
143854
button pushed
143859
button pushed
143864
button pushed
143869
button pushed
143875
button pushed
143880
button pushed
143885
button pushed
143890
button pushed
143895
button pushed
143900
button pushed
143905

... so clearly SOMETHING's fucked up there. Though I this was with the 40-second thing. With
the 30 seconds, I get just one returned value per click:

button pushed
60201
button pushed
65246
button pushed
70740

... Well, mostly. I did get a double-click, although I was able to keep going. Although
two very fast clicks do stillfreeze the program.

I didn't have delays built into my GET requests, let me try that...

Yeah, you know, it seems ALSO that too many GET requests in too short a period seems to
freeze the program. It looks like Heroku disconnects at that point.

OK, one thing I've now done is to tell each http request to do client.stop before making a
new connection...
Oddly, 40 seconds STILL does not work. Ah well. 30 does. Gotta move on.
But why the hell does the 40-second setting still seem to allow for continued clicks????

35 seconds doesn't work either. Maybe it's Heroku's server (Puma, I guess), and how long
it keeps Keep-Alives alive. AHA -- from this page:
https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#timeout
... comes this:
"The Heroku router will timeout all requests that exceed 30 seconds. Although an error
will be returned back to the client, Puma will continue to work on the request as there
is no way for the router to notify Puma that the request terminated early."

... well, there ya go. That's why 30 seconds works and longer times don't. And it doesn't
seem to matter whether there are button-clicks in that window or not -- that doesn't affect
the length of the window.

However, that may explain my ability to keep on clicking with a 40-second setting... that
30 second window may have been being reset with each click.

HEY awesome -- I think this might do it. By setting the lastConnectionTime with each GET
request, it appears I'm able to extend the length of usage, as long as a click comes at
least once every 30 seconds. And then if 30 seconds pass without a click, that's when I
disconnect and re-connect.

That's good enough. Would still like to move the re-connect stuff out of the "if client
is connected" statement, with an attempt to reconnect after 55 seconds... but that's good
enough for now. Move on to solving debounce issue.

OK, as far as I can tell, Heroku DOES NOT LIKE more than four GET requests per 30 seconds.
For some reason, the fifth request fucks things up, freezes the system. This should not
be an immediate issue, but you'll need to know that. (It's either that, or the Arduino
doesn't like more than four GET requests in 30 seconds...)

Hmm, but I'm still getting the occasional issue, where I press the button, and everything
freezes. Maybe not a debounce issue? Or am I debouncing wrongly?

OK, DebounceTest1 seems to work well -- but it's just indicating a press and release, NOT
triggering a GET request...

GOD DAMMIT -- there's still a goddamn issue. I've got a debounce function set up with the
buttons triggering GET requests, and it works, but the shit KEEPS ON FREEZING. God dammit,
I don't know what else to try now.

I think I HAVE to get the re-connect code out of the "if connected" statement. Maybe then
I can avoid the freeze? ACTUALLY though, I already HAD gotten rid of that statement, and
I was STILL having issues. I need to make the whole thing reboot maybe. God dammit.

The worst part of this is that I can't seem to see where the issue is.

OK, part of the issue with the debounce is the GET request. The code I'm following is
not allowing for the wait for the GET request. So whereas I can just click away at a
button and just have the serial output say "pressed-released-pressed-released" etc., I
can't do that with the whole GET request thing. I need more time...

If I could just get this to fucking reboot itself when it freezes...

OK, using my debounce attempt, if I just leave things alone, it keeps connecting (at least
through 7 iterations).
If I do a couple of clicks per round, it keeps connecting.
Huh, actually, no, maybe not. I was testing this, doing one click each round, and then
it started to re-connect for the fifth round, and just froze. What the hell is the issue
with the 5th round?

Huh, this is interesting: I set the debounce to a whopping 150ms, and I actually had to
HOLD DOWN the button for a slight while to get it to register the click. That makes sense,
I guess. And again, this timed out after a few clicks (six, in this case).

SO: No matter what I do, this is shutting down after four-six clicks.

Running out of ideas.

Tried not even re-upping the connection. I was, suprisingly, able to send a GET request
after the 30 seconds that I thought were my limit... but then it froze up on the next try.
I tried just getting entirely rid of the httpRequest to connect to Heroku... but then
no GET request gets sent at all.

... ALTHOUGH, I was able to note that without the connection, I was able to continually
click the button without issue. So the problem here is NOT with the button. It is with
the connection.

Either the Arduino can't handle all these GET requests, or Heroku won't accept all these
GET requests.

Time to try just closing the connection after each button-push and then re-connecting
directly afterward.

Well, that actually works pretty well, and I was able to do a bunch of clicks, but now
the connection to Heroku has been lost, and it doesn't seem to be coming back; it's just
looping through its effort to connect, without success.
HUH never mind, it re-connected now... OK, and NOW it froze...

OK, THIS is probably explaining exactly what my problem is...
http://forum.arduino.cc/index.php?topic=37358.0
... though I don't know that I'm going to be able to fix it. One guy on this thread says,
basically, that you just can't count on being able to connect to the server 100 percent
of the time.

Well, doing a reconnect every time seems to be working all right, although I've still
got to write code that somehow de-freezes me...
Maybe I can make this do something if there's a double-click...
hmm, actually, it looks like a double-click either just freezes it for a sec, and then it
continues -- OR the Heroku connection is lost, but then re-connected. This is good.
... yeah, this isn't too bad. There ARE times when I click, and no GET is sent. Somehow
I still need to check for a connection, and if I'm being told there is one, then figure
out why there really isn't. But after a couple of clicks, the process seems to kick back
into gear, which is cool.

-------------

Tuesday 5/26 3 p.m.

OK, just making a note here that as of right now,
  HerokuReconnectTesting works; and
  WebClient_w_working_buttonS_forGSKOOL works.

... so the first has the timing issue fixed, and the second has the buttons working.
Just gotta figure out how to put them together.

OK, I think I've got 'em together, but you have to be cautious right now: Clicking a button
too soon after the previous click is breaking the whole thing. Even the dis- and re-connect
stops working.

God damnit, still having problems. Best I can figure is that I'm keeping the connection
alive, and then even if I disconnect and re-connect, the connection's ALWAYS been open,
from Heroku's viewpoint, and so then at the 55-second mark, it closes, the connection,
and I'm lost. Wasn't client.stop supposed to avoid this?

OK, MAYBE my issue was that it was going through the loop again, but I had an "if" statement
using client.connected, and since it wasn't connected at that moment, the loop ended
because the "if" statement evaluated to false. I added an if statment for when the
client is NOT connected, and that seemed to do it...

Nah, it didn't -- maybe the loop isn't actually repeating? Maybe I'm getting to the third
and final possibility within my "if" statement, and so it's not going back to the top of
the loop again? But shouldn't it?



-------------

Tuesday 5/18 9:30 a.m.

Do I even NEED to use the pusher client on the Arduino? Well, if not, you'd be sending
GET requests to pusher. That's the same as I'm doing now, basically. Isn't it?

OK, am working on understanding pusher.

2 p.m. -- OK, need to officially give up on websockets. Turns out pusher will ONLY work
with Ethernet connection, not wifi. So that's mostly that.
If I understood websockets better, perhaps I could get into using another websocket library
with the arduino... but for now, you've GOT to get moving. It's time to settle on GET
requests and just making them as fast as you can. If somehow there's time (there won't be),
you can return to this. OK, settled.

A-HA: Check this out, from https://devcenter.heroku.com/articles/request-timeout:
  "Cedar supports HTTP 1.1 features such as long-polling and streaming responses. An
  application has an initial 30 second window to respond with a single byte back to the
  client. However, each byte transmitted thereafter (either received from the client or
  sent by your application) resets a rolling 55 second window. If no data is sent during
  the 55 second window, the connection will be terminated."

That, I think, explains why my clicks were not being read by heroku after 55 seconds.

Also, from this: https://devcenter.heroku.com/articles/dynos:
  "Apps that have only one 1X or 2X web dyno running will have that web dyno sleep after
  one hour of inactivity."
  "Apps that have more than one web dyno running never sleep."
  "When you access the app in your web browser or by some other means of sending an HTTP
  request, the router processing your request will signal the dyno manager to unidle (or
  “wake up”) your dyno to run the web process type."
  "This causes a few second delay for this first request. Subsequent requests will
  perform normally."

Anyway, maybe I can use this knowledge to re-up the connection every 50 seconds, NOT
continuously.







All right, one good discovery is that I can use wifi.getConnectionStatus(), which give
true if I'm connected to the wifi and false if I'm not...

With this code in the setup:
  for (i = 0; i < 6; i++) {
   delay(1000);
   Serial.println("Time: ");
   Serial.println(millis());
   }
... I can get this back:
Time:
10050
Time:
11049
Time:
12050
Time:
13050
Time:
14051
... which is helpful. If that's the time since connection, that means it actually takes
about 10 seconds for this code to process. (Which can probably be mitigated, depending on
if I'm trying to return the IP address, etc.)
    NOTE that you don't want this in the loop. Otherwise you print out five times, then the
loop starts again, and you get another five, etc.

I tried to stick this in the pre-setup:
  unsigned long lastConnectionTime = 0;
... and added this line inside the millis code above:
  Serial.println(lastConnectionTime);
... but was just getting back zeroes. I wonder if that means this is not measuring the
length of the wifi connection, but rather the connection to a server (which I wasn't
connecting to when I tried this...)

OK, I don't think lastConnnectionTime is working for the Sparkfun shield...
... all right, fuck it, I know it times out at 55 seconds, let's just see if I can get
around that.

Let's try delaying 10 seconds upon startup... OH -- actually, that EXTENDS the millis. Now
I'm getting back times of 20000, etc. Well, that makes it a little harder to use millis to
set when a reconnection to Heroku is needed...

Huh, so millis must NOT be measuring time since connection to wifi. What the hell is it
measuring? I know this because I was able to keep moving it further up the chain in my
setup, even above the wifi.init command. The only thing I can't move it above is the
serial port initialization, and actually, I CAN, but then I can't see what it's returning,
obviously.

Well, that may not work anyway. I don't want to count from when Arduino was turned on or
rebooted... do I? Well, maybe I do. If I can get an on/off switch, then Arduino will only
be ON when people are gonna play (i.e., when someone turns it on), in which case establishing
a connection based on boot up time should be OK. Better would be to start the 50-second
countdown on start of GAME...

... Changing the connections to "close" rather than "Keep-Alive" doesn't seem to be helping
any...

SHIT -- I was able to make it restart the Heroku connection depending on the millis... BUT
that seems to interfere with the buttons:
  If I click the button, the first time, I get an increment, but then the millis-restart
code never kicks in...
  And, weirdly, even if I do click the button, it only works once! The second time, it
says "button pressed" but doesn't do anything... and then things are stuck...
  OK, I think the fact that I had set the connections to "close" was the issue for both.
Since the connection was closed, the millis function didn't work... and I had set the
buttons to work only if the connection was open (I didn't NEED to do that, but there's
no point in clicking the button anyway if you're not connected...)

Shit, if I hit the buttons too closely together, that also seems to break things.
Nope, that's not it -- it's either heroku still timing out, or it's my attempt to do
multiple re-connects.
... OK, I'm pretty sure it's the Heroku timeout. I was able to have the connection re-up
at 15 seconds, 30 seconds, 45 seconds. After that it closes out.
A-HA no it's not... I'm able to do another re-up at 60 seconds, no problem. So what is
going on? Well, maybe the heroku connection is ONLY timing out at 55 seconds, and then
so for the buttons to work, I need to re-up AFTER that time? But then what the hell
is client.stop doing? Could it be the case that it's doing nothing, and so whether I
have it in my code or not, the connection's staying open for 55 seconds? In other words,
even though I'm thinking that it's re-connecting, it's just using the same connection?

OK... I think that's big piece of it. I took out client.stop, but then I was NOT able to
go on to the next 60-second re-up. Buttons stopped working after 45 seconds. So
client.stop DID NOT matter within the 55-second window, but DID matter for afterward.

And THIS is interesting. I closed the serial port and reopened it. And then things got
wonky. The buttons stopped working at different intervals -- sometimes after the 15-second
re-up, sometimes after the 30-second re-up. I'm not quite sure what was going on there...
but I'm pretty sure I need client.stop.

Yeah, I just set a timeout for 50 seconds. Without client.stop, I think I've verified that
Heroku times out on its own (this is with Keep-Alive connections), because the buttons just
don't work after the re-up. But what's weird is, WITH client.stop, the buttons work after the
re-up, but only briefly -- about 10 seconds, or five clicks worth. What the fuck?
... yeah, I think it's a TIME thing and not a number-of-clicks thing (which makes much
more sense.)

I was even able to do 15, 30, 45, 60, 75, 90 -second re-ups, and everything worked until
about 10 seconds after the last re-up.

Yet if I set just a 50-second and a 100-second timeout, I'm only able to go up to, and a
little past, the 50-second mark. But obviously the re-up doesn't HAVE to happen only after
the Heroku timeout, as evidenced above. So what's up with this?
Maybe there's an issue (there might be) with the large number I was using for the
second timeout -- 100000? Or maybe 50000 is too close to the cutoff (due to variance of
millis), and actually, the problem is that I've got to get client.stop to act before the
heroku timeout?

Damn, I just don't get it. I tried a 45-second and 90-second timeout, and yet this died
10 seconds past the 45-second mark. And yet somehow I was able to do the 15-30-45-60-75-90
above!
And yet I WAS able to use a 40-second and 80-second timeout, and got all the way through
the 80-second mark! (Although buttons stopped working after that.)

Huh, I tried a 40, 70, 80 timeout structure, and the 80 never kicked in. Maybe just too
close to the other?

How weird! I tried a 40, 65, 80 without success. So how was I able to do a 40, 80?

Tried using this type of code: millis() == 60*1000... but then it doesn't recognize the
millis value at all. Hokay...

OK, maybe the real issue here is that once you've "cleared" all the if-statements involving
millis, there's no more re-up, and then the buttons stop working because the loop has an
if client.connected statement.
... damn, I thought that might be the answer. Added a delay, but buttons still seem to
die on the vine after the final timeout.

Hmm, well, I may have corrected one issue. I had a delay at the start of my connectHeroku
function. So maybe that delay... well, I dunno, left an opening for Heroku to close its
connection on me and therefore not allow me to do client.close?

... Yeah, I think that was an issue. In fact, now things look promising. Was just able to
do a 40, 55, 80, 95, -second structure, and then a 40, 55, 80, 95, 120 -second structure.
In both cases, was able to make it to the final timeout, and then a few seconds afterward.

So first of all, looks like I CAN use six-digit numbers like normal.

And it seems pretty clear that those few seconds I'm getting after the final timeouts are
due to using the "keep-alive" connection. Yeah, VERIFIED that using a "close" connection,
at least with the way my code currently is, means that I get only ONE click of the button.
The program then immediately is over. I click the button again, and the serial port registers
the click, but the number is only incremented the first time.

So I'm still confused about what the millis mean, and they seem to indicate time since
whatever last connection, whether just turning on the Arduino, OR connecting to wifi, OR
connecting to Heroku. Because isn't that the connection that's being closed when I use
the "close" connection setting? The connection to Heroku? And isn't that why my code as
written won't work with the "close" connection (because all the if statements involving
millis never come to pass)?

I guess I'm gonna have to get more systematic about trouble-shooting this, but for now,
fuck it, let's try the way Wesley suggested. And actually, I might be mostly there. It
appears that I could just continue to write if statements with incrementing millis counts
and that the program would continue to work until a few seconds past the last if statement.
If that last if statment triggered a GET request with a "close" connection, I'd only get
one more successful click following. Because of the "keep-alive" connection, I'm able to
get a few more clicks before timeout.

So I've actually still been connected to Heroku when the buttons have stopped working...
it's just that the program has... well, actually, it shouldn't end, but I guess, for
some reason, since all the if statements have been executed at that point, it loops back,
allows for one more execution of the button-press code, and then... I dunno, either ends
or gets stuck.






I'm getting bad connections when I close the serial port and re-open it without having
changed a sketch. Don't know what the issue is with that, but I think it IS my issue,
because unplugging and replugging the arduino seems to make the connection work again...

It DOES also seem that the buttons are fucking up when I click twice quickly (like, a
second apart...) -- Yeah, I DEFINITELY think that's an issue. I think this is actually a
DEBOUNCE issue. Will have to try to add that soon.

UGH -- it looks like there may be errors if I try to click the button while the re-connect
is going on...

OK, here are the concerns I need to address with code:
  -- re-up connection to Heroku every 50 seconds.
  -- check for dropped wifi connecting and restablish if necessary.

OK, so I'm not clear on why exactly this connection is quitting on me. Need to add some
serial indicators.

Currently, what I see is:
  Performing HTTP GET of: pongtester.herokuapp.com
  button pushed
... and then after a while the buttons are just not responsive.

establish wifi connection
alert if wifi not establish, otherwise
establish heroku connection (maybe only on game start?)
alert if heroku connection not established, otherwise
allow for button clicks for 50 seconds
close heroku connection
restablish heroku connection
go back to allowing button clicks

... and, I guess, continually check for wifi connection and heroku connection?

BY THE WAY, as far as power needs, I saw something that said the cc3000 needs 3.3 volts...
am I giving it too much or too little power with my 9V? Why can't it just take what it
needs?
Internet sez: "Correct. You'll need level shifters (2 resistors) for WLAN_EN, WLAN_CS,
WLAN_MOSI, and WLAN_SCK, and 1 resistor for the 3.3V pullup for WLAN_IRQ."
The 9v battery may not provide enough current to power the wifi shield.
They normally take a bit over 100ma.
Hey, are there sparkfun cc3000 docs anywhere? How do I know what all methods I can use?

is using a http 100 continue going to do any good...

-------------

Monday 5/17 1 a.m.

With basic functionality happening and websockets not happening, I'm gonna try to add a
second button and see how that goes.

OK, just did a little setup. For some reason, I can't make pusher operate on a second
button. Not sure if I need to create a new pusher instance or what. Well, not to be
worried about for now; I'm not even using pusher currently.
... nah, nevermind, just was moving too fast. It's all working now, including making
postman GET requests to my functions. AND HEY: You ARE actually using pusher currently.
You'd forgotten, but just a GET request to a controller action wasn't triggering anything.
You needed pusher to do that. (I mean, there's surely a way I wouldn't need to use pusher,
but be sure to note that you ARE.)

OK, just checked, first button still works with new design elements...

Also, I notice that my loop, when it can't connect, keeps looping through the attempt to
connect, and keeps returning "could not connect" messages. I hope that won't crash shit...

OK, got button hooked up and working -- which suprisingly didn't take me too long. Cool.

However, the wifi doesn't seem to be working with external (9V) power source! That's odd.
It was working when I had only one button. I suppose maybe I'm draining too much power
now. Will have to look into that...

-------------

Saturday 5/16 8:30 p.m. - Sunday 5/17

OK then. Was still going hard at it yesterday, trying to initiate a GET request using just
the Arduino (pressing the button which would then fire off a GET request from the wifi
shield). And, well, you learned something: Don't fucking set up Arduino loops without
some sort of closure! Because I had given the Arduino instructions to just keep printing
"not clicked" as long as the button was not clicked. And it looped so fast that it crashed
my computer, including all my precious, precious tabs. Anyway, after rebooting and some other
nonsense, back at it now.

OK, so, I can use a simple button sketch, even with the shield attached. All this does is
let me turn on the LED at pin 13 (on the board itself) by pressing the button.

I was able to stick that button code into the WebClient code, and I can run either the
WebClient GET of pongtester (at least the main page), OR turn on the LED by pressing the
button, but NOT both. Whichever I do first works, and the other does not. Hmm. Perhaps
because the wifi using pin 13, as does the button?

COOL -- well, I can now run the WebClient, and have it only return what it GETs while the
button is being pushed... otherwise, it waits... so will that work with /alsonumberup?
Not quite, because the GET in this case is triggering a method, and so that happens even
before the button push. What I need is an IF statement in the setup itself, and I'm not
quite sure how to do that...

OK, I'm sure I'm doing this in a very hapharzard way, but nonetheless, I'm now sending a
GET request to /alsonumberup, USING the Arduino button and wifi!

... there's gonna be a LOT of functionality to figure out, though. Not least of which is
that currently, the button only triggers the GET request once. And then no more.

OK, so I though that for some reason the wifi was only launching upon the opening of the
serial monitor, but that's not the case -- opening the serial monitor simply RESTARTS the
Arduino program. And I've verified that if I just don't open the serial monitor, the
program functions the same way (on Heroku page, the number increments). And it apparently
doesn't matter if I've got all that Serial.println stuff in the code (at least, not when
the USB is connected. I don't know if that'd be an issue if the Arduino couldn't detect a
serial port...)

An interesting note: I can still only get the button to trigger the increment once. I tried
using pin 2 (and changing code accordingly), but that made the request IMMEDIATELY fire,
not waiting for the button push. I'd guess it has to do with an embedded pullup resistor
for pin 2? I dunno. But since pin 5 is working, I'm just gonna stick with that for now.

HUH! So now, changing the code to read Connection: Keep-Alive, I can click the button five
times with success... but only five! What the hell? ... OK, it looks like there's a default
timeout even with the Keep-Alive notation... and apparently that default timeout is after
five transanctions! Odd.

Although I put in code to make the Arduino show me when it was connected or not connected,
and it's not showing me any "not connected" status... but the button stops affecting Heroku
anyway.

Note that you have taken out this stuff, as you currently don't need to get data back from
the website...
    if (client.available())
   {
     char c = client.read();
     Serial.print(c);
   }
... far as I can tell, this hasn't affected things...

Holy Christ, well, I got it. At least a big piece. By closing and restarting the connection
each time the button is pressed, I can can continuously press the button and increment the
number. WOW

... it's funny how hitting that big piece still kinda feels anticlimactic. Weird. But I'm
a'pressin' on.

So -- I do want to check to see if the connection times out. I suppose it will... after all,
the wifi connection is currenlty set to time out after 30 seconds. HUH but it doesn't look
like it's timing out! I wonder why not. Maybe that timeout is just supposed to stop if
the connection isn't made after 30 second, but is not supposed to close the connection after
30 seconds. That would make more sense.

OK, there IS a timeout issue -- I waited five minute before testing this... right now, I
have to hit the button to restart the connection process... and THEN I can hit the button
again to increment the number. THAT's a fix I'll want to make, somehow...

However, I'm gonna hold off on websockets for now -- these GET requests may be fast enough,
since I'm not actually looking to get any data back. I don't know that the back-and-forth
that would be necessary for authorization would provide any faster solution -- and again,
I may not need any faster solution. The delay right now is about a second -- I can live
with that for now, I think. Besides, working with websockets is gonna be tough. Look at how
many hoops you had to get through to get websockets working on Heroku, just with a Ruby app.
You're gonna have to use callbacks and shit, programmed on the Arduino, to make them work.

... yeah, as far as I tell from a brief look, websockets will be the way to fix that
timeout issue. I'd probably have to have the Arduino continuously pinging to keep the
connection open.

So it looks like, right now, I can get about 50 seconds before the button stops working on
first click. After that amount of time, you have to click it once to "prime" the code, and
then again to increment. Not the end of the world.

-------------

Thursday 5/14 5 p.m. - Friday 5/15

OK, after a bunch of reading, it seems that I need to create PRIVATE CHANNELS in order to let
a client (such as the client pressing the button) trigger an event. Am going through the
process of doing so on localhost...
... am seeing the right thing when I load page -- a 404 error ("couldn't get auth info from
your webapp"). And then clicking on button gives a 500 ("internal server error"). That's the
one that's worrisome.
... then again, maybe not. After setting up routes for the callback, I'm pretty sure it's
now going to the right spot... just not working because the setup isn't done. In other words,
I'm no longer seeing a 404 error, just a 500 error.

  OK, this may be awesome?  Following https://github.com/dipth/pusher_demo, I added access to
  to the pusher key within the browser window. Then, I started the Rails server,
  then went to browser window. Interestingly, as soon as I clicked on the tab,
  there was some movement in the terminal  -- although I guess that makes sense;
  the javascript stuff is firing only on the... well, I guess the "activation"
  of that specific window, although I don't know exactly what function is doing
  the activating (load? ready?) -- and so I saw this:

  Started GET "/" for ::1 at 2015-05-15 10:35:57 -0600
Processing by LedController#index as HTML
  Rendered led/index.html.erb within layouts/application (2.1ms)
Completed 200 OK in 667ms (Views: 666.2ms | ActiveRecord: 0.0ms)

(then some of the usual GET "assets/etc." stuff...)

Started POST "/pusher/auth" for ::1 at 2015-05-15 10:35:59 -0600
Processing by PusherController#auth as */*
  Parameters: {"socket_id"=>"45441.3484269", "channel_name"=>"private-button"}
Completed 200 OK in 2ms (Views: 0.3ms | ActiveRecord: 0.0ms)

THEN, I refreshed and saw this:

Started GET "/" for ::1 at 2015-05-15 10:36:21 -0600
Processing by LedController#index as HTML
  Rendered led/index.html.erb within layouts/application (0.1ms)
Completed 200 OK in 40ms (Views: 39.2ms | ActiveRecord: 0.0ms)

(then some of the usual GET "assets/etc." stuff...)

Started POST "/pusher/auth" for ::1 at 2015-05-15 10:36:21 -0600
Processing by PusherController#auth as */*
  Parameters: {"socket_id"=>"45439.3485084", "channel_name"=>"private-button"}
Completed 200 OK in 1ms (Views: 0.3ms | ActiveRecord: 0.0ms)

AND, THIS IS GOOD, no visible errors when I look at the inspect-elements network
tab! Whereas before, I'd been getting that 500 error! So as of now, I can see that
pusher is sending me a socket_id and channel_name. And a response, in the form of an
authentication hash, is being sent back. But that's actually got me confused. I haven't
placed any code yet that is supposed to be TAKING the socket_id and channel_name and
CREATING a hash out of it. Huh... Why would that be working?

Now... as far as the button goes, it still works, and yet I still get a 500 error each time
I click the button. Not sure of the cause or the solution.

OK, so I pushed to Heroku just now, button still not working. But there are TWO errors going
on in Heroku vs. one error in local host. On Heroku, when I refresh the page, I get an error
that says, basically, code 4005: path not found. Then clicking button gives me a 500 error.
So I assume that fixing the FIRST error would make it so I could get the button on Heroku
working, even if it was still showing the same error as on localhost.
... by the way note that the "maybe" view is now not working either, although I don't
think that's a concern since I've been fucking with stuff. It was working before,
even when the button wasn't -- I think I need to reset the Heroku config stuff...

OK, so I got rid of the "window.pusher_key = '<%= ENV['heroku_key'] %>';" line I had
placed in my application layout file... (I had thought maybe that was what I needed,
based on what I saw at https://github.com/dipth/pusher_demo), and then re-added the
heroku-specific pusher app_id, key and secret using Heroku config... ANNNNNDDDDDD success!

YAH! So I just checked, and the button works on both localhost and Heroku, and the maybe
view alert works on both localhost and heroku. For fuck's sake, I can move on. Although
I'm still seeing that "GET http://localhost:3000/alsonumberup 500 (Internal Server Error)"
on both, I'm gonna assume for now that's just an issue with the GET request looking for a
template that isn't there.

But will that GET error cause an issue with my attempt to make a GET request to these sites
from other sources?

Well, not in localhost. I get a "template is missing" error.

All, right, AWESOME. I needed to add "render :nothing => true" to the action. Now, when I
make a GET call with Postman, and have my Rails server running, my localhost page is
responding (by incrementing the number.)

AND this works on Heroku!!! Ho fuck! I might be on the verge of actually making my Arduino
affect Heroku!!

OK, so first I've tried just a simple Arduino GET of the Heroku site. (Connection to my wifi
is spotty, but that's just fine for now.) And that GET request is still working. Now...
OH. FUCK. YEAH. It worked. I can make that GET request, and the number goes up. How many
fucking hours did it take to get here. Too many.

OK, I've spent some hours now just getting to the point where a test page (not in this app;
it's in the buttontester app) has a button that I can click to execute a get request. I
can now do that; however, I can't yet get my arduino button to do that. One interesting thing
of note: right now I'm using the Dino rb file, and just using the button to fiddle with
localhost still works fine. However, if, under the button.down do command, I take the quotes
off of 'up', then, even though I haven't fiddled with the button.up do command, which tells
it to put 'down' -- still in quotes -- NOTHING HAPPENS. So there's some kind of breakage
happening here upon the first error. I didn't expect to see the terminal print 'up', but I
was suprised that 'down' wasn't appearing, either. Anyway.

HEY, YOU GOTTA REMEMBER to refresh browser when making changes. Otherwise page doesn't have
the new stuff. Thanks, "inspect element". I almost thought that I wasn't able to press the
button, and through a circuitous route, get my localhost number to increment. I saved myself
a lot of time by inspecting element and seeing that the page didn't have my updated code.

Oh, and yes, now I can do an Arduio GET request with a button push. At least to example.com.
Trying to read localhost doesn't seem to work, but that makes pretty good sense, since I'm
trying to set a GET request using the same program I'm trying to GET from.

I CAN do a GET request to the main Heroku page using an Arduino button push. Test time: Can
I do a GET request to /alsonumberup and have the number go up?

AWESOME. Yes I can. For the very first time, I can push the button and make Heroku change.
Awesome. Really. Still a lot of work to do, obviously. But this is good.

-------------

Monday 5/13 8 p.m.

  OK, going to try to use the Puma webserver for Heroku, mainly just for (hopefully) added
stability.
  -- Heroku says: "You can only utilize threads in Puma if your entire code-base is thread
  safe." I assume mine is. Not gonna worry about that for now.
  -- also, this is kinda mainly for a app where multiple people will be using it at the same
  time. Nonetheless...
  -- You'll have to keep an eye out for possible timeouts, and take appropriate action.
  -- So when I start Rails server now, I see this (just noting it...)
        Puma 2.11.2 starting...
      * Min threads: 0, max threads: 16
      * Environment: development
      * Listening on tcp://localhost:3000
  -- OK, all good as far as I can tell. Can see page on localhost, can see page on Heroku.
  HOWEVER... the "alsonumberup" button DOESN'T work on Heroku. And I'm not sure why! I'm
  seeing, in the Heroku logs, a "500" error, which, according to Wikipedia, is "A generic
  error message, given when an unexpected condition was encountered and no more specific
  message is suitable." Well, maybe I can't trigger the same Pusher action in two different
  ways -- at least via Heroku.
  ... OK, the logs also say "Pusher::ConfigurationError (Missing client configuration:
  please check that key, secret and app_id are configured.):"
  ... uh oh, you know what? The "also numberup" is the ONLY method that is currently using
  Pusher. So that's a problem. Heroku is not responding to Pusher.
  ... OK, well, Heroku config tells me that it does see Pusher key, but not the other stuff.
  Even though I'd thought I'd made that accessible...
  ... well, the guidelines say to configure your app for development mode only, so I've cut
  out the stuff I had in the production.rb file (just the same stuff as in the Dino.rb file...)
  -- So now, localhost still works in full, Heroku site... same thing still. Not reading the
  client configuration.
  ... OK, took out all the stuff about the Dino board in the development.rb file. THAT's gotta
  do it, right?
  -- localhost still works in full, Heroku site... still not in full.
  ... For Heroku config, I had tried to use ENV['app_id'], etc., but I've now changed that to
  more simply Pusher key = 0000000, etc....
  -- that's not doin' it.
  ... OK, tried defining the app_id, etc., within the method I was calling... (still don't
  see why this should be needed when it wasn't needed on localhost...)
  ... still no good... maybe it's the Dino.rb file? So let's get entirely rid of that...
  -- still no good. Shit, I'm at loss now.
  ... tried moving pusher gem to production group, no good.
  ... tried deleting pusher yml file (wasn't using it anyway), no good.
  ... OK, huh. Tried using the example test that Heroku provided. On a different page. And the
  first time I tried, the page rendered, although the alert didn't fire. And then the second
  time, I got an error message. And the Heroku logs show that the first rendering was fine
  and that the second gave me a 500 error again.
  ... and after I went back -- after a couple of minutes -- same thing again. First time
  rendered although alert didn't fire; then I went to a different page; then back to the
  original page, where I got an error message.
  ... I dunno. Really I don't.
  ... OK, let's get rid of reference to Pusher key, etc., everywhere else... and leave that
  solely in development.rb, as I was told...
  -- OK, fuckin' FINALLY. The first time I went to the page, it rendered, as before, without
  doing anything. But second time around, for Christ's fuckin' sake, the alert popped up.
  JEEEESUS what a fuckin' problem. It's now midnight. This has been my whole night.
  ... huh, so I put back some of the stuff I took out, just to see if I could pinpoint the
  problem. I put back the stuff that related to the "alsonumberup" button, and that stuff
  still doesn't work, but the alert still does. I can't figure why the button won't work,
  though, if the alert will. Maybe I bound that earlier channel, somehow, to the earlier
  api key, etc. Maybe it's an issue with not having a view associated with that action.
  Maybe I'm setting global variables for both Pusher.new's and both channels that have the same
  name, and so those are fucking with each other.
  -- Nope, that last one's not it; I tried changing one pair; no success with the button still.
  ... although on localhost, BOTH the button and the alert work.
  Weird, even though localhost WORKS, in "inspect element" I can see errors: It says:
  "GET http://localhost:3000/alsonumberup 500 (Internal Server Error)". So why does the button
  work anyway? Is this just a problem of using the verb GET, and somehow localhost weasels
  around that, but Heroku won't?

  OK, fuck the button. Can I get pusher to make the fucking number go up?

-------------

Sunday 5/10 1 p.m.

  New approach. See if you can send a GET to Heroku, then see if you can program
  Arduino to do that.

  Huh, note that running Rails c ALSO says board is not found. Why is it not found?

  Note that you've ADDED A CREDIT CARD to Heroku in hopes of add the pusher addon,
  which isn't functioning correctly yet...

  Was taking a look at how Javascript was working on Heroku page (as part of trying
  to just make a GET request to that page). Was seeing an error saying something along
  the lines of "you have to declare your API key when you instantiate Pusher." Not
  sure what did it, but after updating the pusher script call in my application layout
  file, and getting rid of two extra jquery script calls, and moving the pusher script
  call above the jquery call, and sticking Pusher.app_id = ENV['app_id'] in several
  spots, including the index definition in the controller, as well as the development
  and production environments files... AND adding the Heroku pusher addon... that error
  is gone. Ooofah.

Sunday 8:30 p.m. After a couple of adjustments (see way at the bottom), I can
PERFORM A GET REQUEST OF HEROKU. Oh hell yeah. Now: Can I make a GET request that
doesn't return the page but rather makes something happen?

OK, so this doesn't work in postman:
pongtester.herokuapp.com/numberup
... but THIS does:
pongtester.herokuapp.com?numberup
... although it doesn't change the number...

Well, you can enter pongtester.herokuapp.com?blah and the page still renders...

OK, my postman call to pongtester.herokuapp.com/numberup, as stated, didn't work...
but didn't return a 404. It says "the change you wanted was rejected". Checked the
Heroku logs, there's this: "Security warning: an embedded <script> tag on another
site requested protected JavaScript. If you know what you're doing, go ahead and
disable forgery protection on this action to permit cross-origin JavaScript embedding."
... now, I have no idea what I'm doing whatsoever, but what the hell. Took out the
protect_from_forgery line from the Application controller...

But all that happens then, if I make the pongtester.herokuapp.com/numberup call, this
gets returned:

incrementValueBig();

... and that's it. Nothing else on the page.

Hmm, the internets tell me: "Browsers do not provide an API for listening for any HTTP
request." So that's maybe not an option... but then what is?

I suppose websockets. So that they're constantly listening for updating information.

I dunno, does that mean I'm back where I was?

-------------

Saturday 5/9 10 a.m.

Could this just be an issue of not waiting long enough for a connection? Well...
maybe. I certainly do see the TCP error pop up sometimes in situations where I haven't
come to expect seeing it.

Adding "TCP" to the connection arguments like so:
  if ( !client.connect(server, 80, TCP)
... does not work... even though I got idea from a comment on SparkFun page that was
only a year old...

OK, think this through:

Three issues here:

  1. Can't press button and have heroku site change.

      Button press can be recognized by my computer via USB.

      When running Rails server on my computer, button press works. Why.

      Because computer recognizes board, and therefore can read the button press.

      There is no code on the Arduino telling it what to do with a button push. BUT
      because I'm using Dino, the Dino code on the Arduino is able to read my Ruby
      code. The Ruby code is running the show as far as recognizing a button push
      and making things happen when it recognizes that button push.

      Heroku can't sense the board is there. That is the first and crucial issue.

      Upon deploy, it says as much: "The board is not connected." So...

      Two potential issues here:
        1. Some folks are using ethernet cables
        2. some folks are using node.js.


  2. Can't connect to localhost to test wifi.

      This is actually not a necessary step but a half-step. So maybe I should stop
      fucking with this step.

  3. Can't get wifi to connect to Heroku.

      From what I can surmise, this is an issue with the https. Can get wifi to do
      GET requests to other sites. So this maybe is pretty solvable if you just
      get a domain that doesn't have https.

      I think I need to totally give up on wifi for now, though. It's a complicated
      issue. The goal should just be to click, and have heroku site change. That way,
      at least, a player:
          -- brings computer to table and plugs in
          -- logs in to Heroku site on same computer
          -- Heroku site reads button presses and acts accordingly.

Saturday 3 p.m. Can't figure things out, need to start thinking about quitting or
asking for some serious help. Just don't have the knowledge. Nonetheless, am back
on trying to connect via wifi...

    -- As always, can connect to www.example.com
    -- If I change "client.println("GET /index.html HTTP/1.1");" to
    "client.println("GET / HTTP/1.1");", still works fine.

    HOWEVER, my app doesn't HAVE an index.html. Could this be the issue?

    Well, "client.println("Host: pongtester.herokuapp.com");" doesn't work, but that
    could be because of the https issue...

    But trying to connect to my local host with just the / doesn't work either...

-------------

Thursday 5/7 midnight

changed production.rb code; added:
config.force_ssl = false
Nope, didn't work.

if that doesn't work, try just renaming Heroku site to
http://whatever
... and see if that works.
Nope, won't let you do that.


if that doesn't work, you might try this in config file:
config.allow_ssl_in_production = false


-------------

Wednesday 5/6 8:30 p.m.

Where are we:
  With shield attached, am still able to upload dino sketch and then can run app via
  local host. (Changed button input to pin 5; I think that that 2 wasn't available with
  the shield, although I can't remember if I tried it or not.)

  Also with shield attached, can connect to internet from home and send get requests to
  some sites, although currently not Heroku.

  ... Well, I wrote the above, but now I AM having issues connecting. The internet
  connection test isn't returning anything.
  ... OK ran a test, and it shows Arduino isn't identifying the wifi shield at all.
  ... In fact, I took off the shield and tried just the basic app on localhost, and
  terminal tells me the board is not connected!
  ... huh, so I saw that the usual serial port I was supposed to be using was not
  listed... which I guess stemmed from me upgrading to Arduino 6.3 yesterday. I
  know this because when I opened 1.0.6, I was able to see that port was available.
  And now, my app is once again OK to run on local host.
  ... and connection test works again.

  Don't tell me I'm gonna have to read all the Arduino update notes to figure out
  if I should stick with this version or get the right drivers working on the latest
  version...

  Well, I did see something about 6.3 fixing an issue with being able to connect
  to urls that start with https, and my Heroku app is one of those, so...

  OK, tried using "heroku console" command in terminal, that is no longer offered.
  Was able to do "heroku run rails s" instead, but it doesn't recognize the existence
  of the board... So I've gotta think that pretty much answers that I'm not going to
  be able to affect Heroku via a button plugged into my computer (never had planned
  to, anyway -- but it woulda be a helpful midpoint. I suppose I could get a program
  to trigger a pusher event and therefore Heroku, but... nope, not unless I'm
  totally out of ideas).
  ... while reading a bunch of Heroku info pages, saw an option to use "heroku run
  bash". Which I did... but same issue: "the board is not connected".

  Maybe try to connect to local host via wifi then use buttons? Maybe. But that's
  going to involve new challenges.
  If you're gonna try that, see this:
  http://forum.arduino.cc/index.php?topic=177527.0
  Googling "how to find my ip address" returned this: 75.166.2.229 (as my "public"
  address...)
  ... although when I'm trying to connect via the shield, it tells me that the IP
  address is 192.168.0.20
  HOWEVER, looking up my ip address on the mac returns something slightly different:
  192.168.0.4 -- this should be my "internal" ip address...
  And it give my router address as 192.168.0.1, so I don't know where that "20" is
  coming from...
  Neat, if you enter 192.168.0.1 in a browser, you actually get a page corresponding
  to the router...
  ... although I don't know if that's the right address, or if there's a second one
  associated with my computer, or if I need my router address.
  ... by the way, the Google IP address provided by the above site didn't work for me,
  but don't know why.
  Note that you can type "127.0.0.1:3000" into your browser window (while
  Rails server is running) and see the page you're seeking...
  But even with Rails server running, "192.168.0.4:3000" and "192.168.0.4:3000" don't
  do anyting. They immediately say webpage isn't available. Interestingly,
  "192.168.0.20:3000" at least appears to be trying to connect... same with
  "75.166.2.229:3000"
  From the web: "If the Mac is connected to a network as well as the internet, then
  it will have an internal IP address which marks its location on the local network,
  and an external IP, which is the IP address of your internet connection. "

-------------

Tuesday 5/5 midnight: Can't quite figure out how to access Heroku through the wifi.
Can connect to other sites like www.example.com and www.google.com. Since my Heroku
site doesn't have a "www", had to use the server "http://aqueous-scrubland-2496.herokuapp.com".
Seems to almost connect, then says it can't make a TCP/IP connection.

Also: Downloaded the Adafruit library, but that just wouldn't work. I thought it
might. Guess the code don't match up. Still, the sketch that Adafruit suggested
may have some usage for me... Although I just tried to delete it, so you might have
to find it on the web. Also, try to get rid of the Adafruit Library listing under
"Examples" (as well as any other associated files.)
... and also try to get rid of the SFE_cc3000_Library-master2 listing. I think I deleted this too...

Huh, the on-off buttons that turn on/off led on arduino aren't working anymore. Not
worrying about that, though -- button still works.

----------------------

may have to use ruby version 1.9.3 to make this work?

Huh, so it appears that not precompiling my assets (by adding the lib/assets.rake file
and its interior code) doesn't stop my app from running locally... but it does slow it
DOWN a fair bit. It's now not always registering clicks; and also, the outpput in the
terminal is decidedly slower. In fact, sometimes the click registers on the webpage but
NOT in the terminal. Strange.
... No, maybe that's not the issue. My computer is moving slowly suddenly. Apparently
because of all the Heroku push attempts I just made, although I don't understand why
that'd be an issue... Seems to be an issue only with the button; using the in-page
button works fine. Hope I didn't overload my Arduino...
... well, I unplugged it, stopped Rails server, re-plugged it back in, re-started Rails
server and all is well again...

... However, the addition of that assets.rake file did not fix the Heroku-push error.

... oh, wait, I THINK stuff has to be pushed to GitHub first, then to Heroku. I think
you're supposed to be able to skip the GitHub step, but maybe I'm configured to
require that.

... Huh, that did it. I STILL got the error saying that the rake had been aborted, and
that I had an unitialized constant YAML... and yet the deploy was complete, apparently.
Now, though, can I use this app via Heroku, or did I just block something that was
necessary to have?

Well, can't even see Heroku page for now... page said error occurred in application.
Thought it might be a database issue. Tried to migrate database, it wouldn't let me...

Hmm, I wonder if that's an issue with using Pusher.

Well, someone on the internets told me, and maybe I knew this, I dunno, that you DON'T
do a Heroku db:create. It won't let you. You instead to a db:migrate.

OK, so next issue is back to same I've seen before: unintialized constant YAML. So
neither a push nor a db:migrate will work till I've fixed this issue.

OK, so, added the 'dotenv' gem, and a ".env" file with the pusher stuff in it, and
added the ".env" file to the gitignore file. App still working locally, athough
seems to be moving slower. Could be an issue other than that of the code changes,
though...

... Actually, the "moving slower" thing was due to the connection loosening... that was
an easy fix, although not the first thing I thought of...

Fiddled with moving things around more, in order to make pusher yaml file "viewable" by
Heroku, and was able to push to Heroku once more... BUT still saw same error of
'unitialized constant yaml.' So... yep, still can't open Heroku page.

So one thing I think I'm verifying here, and maybe I knew this once upon a time, but I
had damn well forgotten it, is that with my current app settings, I am UNABLE to push
changes to Heroku unless I first push those changes to GitHub. (I suppose it's possible
that all I have to do is COMMIT changes, not push them, but whatever.) YOU INDEED
VERIFIED THIS; YOU HAD THE GEM 'PG' TWICE IN THE GEMFILE, THEN COMMENTED OUT ONE OF
THEM, AND THEN TRIED TO PUSH TO HEROKU, BUT ERROR STILL SAID YOU HAD TWO LISTINGS OF
THAT GEM. AFTER YOU COMMITTED YOUR CHANGE AND PUSHED TO GITHUB, YOU WERE ABLE TO PUSH
TO HEROKU WITHOUT THAT ERROR.

So: It's a good lesson, one that will take me forever to learn, but still:
  You had been trying to push to Heroku for... what? At least a few hours? And each time,
  you saw an error message that said you had the gem 'pg' listed in two different
  places in your gemfile. But then there also was that "uninitialized constant YAML"
  error, and so you were concentrating on that. FOR HOURS. And then finally you
  decided to just get rid of that small error that you were sure was not the problem.
  And after you did, you were able to push to Heroku.
    For fuck's sake. I don't even know if that solves all of my Heroku-push problem,
    but it sovles one I'd been at for hours. You have really got to slow your roll a
    bit when problem-solving. If I'd just read that error and tackled that error first...

Once again, just for the notes:
  Removing the 'pg' duplicate from my gemfile (the one NOT under group :production do)
  solved my issue.

Indeed, even though I had created a lib/assets/assets.rake and added this:
  Rake::Task["assets:precompile"].clear
  namespace :assets do
    task 'precompile' do
        puts "Not pre-compiling assets..."
    end
  end
... that turned out not to be the issue.

The answer was staring at me the whole damnin' time.

OK, SO AFTER ALL THAT... pushing the button does nothing to affect Heroku. Maybe I
should have expected that. Then again... well, more to look at.

Preliminary look makes it seem as though I needed wireless NOT ONLY to get cords away
from ping pong table, but also to reach Heroku in the first place. Though I'm not
convinced. Why WOULDN'T Heroku site be able to respond to this?

HEY I did good that time. Couldn't connect Arduino to wifi. Only spend about 20 minutes
looking online before I just went back and considered that my network password was
wrong. Fixed password, and got connected. Cool.

----------------------

So here are the pins that I think are off-limits (this comes from
https://learn.sparkfun.com/tutorials/cc3000-hookup-guide):

The pins used by the shield are as follows:

2 (INT) is the interrupt pin that the CC3000 uses to notify the Arduino that it has data.

7 (EN) is the enable pin that the Arduino uses to turn the CC3000 off and on.

8 (SDCS) is the chip select for the SD card.

10 (CS) is the chip select for the CC3000.

11 (MOSI) is the SPI communication line from the Arduino to the CC3000.

12 (MISO) is the SPI communication line from the CC3000 to the Arduino.

13 (SCK) is the SPI clock line.

--------------------------------

This is pretty interesting -- here's what I got when trying to connect to unsecured
network at Galvanize Platte:

---------------------------
SparkFun CC3000 - WebClient
---------------------------
CC3000 initialization complete
Connecting to SSID: galvanize guest platte
IP Address: 10.6.66.128
Performing HTTP GET of: www.google.com

HTTP/1.1 307 Temporary Redirect
X-Frame-Options: deny
Cache-Control: no-cache
Location: https://n76.network-auth.com/splash/?mac=00%3A18%3A0A%3A08%3AE5%3A50&client_ip=10.20.161.111&client_mac=70:FF:76:02:05:06&vap=1&a=f1abd670358e036c31296e66b3b66c382ac00812&b=78604&auth_version=5&key=b87659b9cf9b8e785eea48a06fb4b2cb99677e4f&acl_ver=P351250V2&continue_url=http%3A%2F%2Fwww.google.com%2Findex.html
Content-Type: text/html
Pragma: no-cache
Expires: 0
Continue: close
Connection: close
Transfer-Encoding: chunked
Server: lighttpd/1.4.35

17b
<html>
<body>You are being <a href='https://n76.network-auth.com/splash/?mac=00%3A18%3A0A%3A08%3AE5%3A50&client_ip=10.20.161.111&client_mac=70:FF:76:02:05:06&vap=1&a=f1abd670358e036c31296e66b3b66c382ac00812&b=78604&auth_version=5&key=b87659b9cf9b8e785eea48a06fb4b2cb99677e4f&acl_ver=P351250V2&continue_url=http%3A%2F%2Fwww.google.com%2Findex.html'>redirected</a>.</body></html>

0

Finished WebClient test

--------------------------------

When I tried to connect to www.example.com using what I THOUGHT was its IP address,
I got this:

---------------------------
SparkFun CC3000 - WebClient
---------------------------
CC3000 initialization complete
Connecting to SSID: LolaDog
IP Address: 192.168.0.20
Performing HTTP GET of: 93.184.216.119

HTTP/1.1 200 OK
Accept-Ranges: bytes
Content-Type: text/html
Date: Sat, 09 May 2015 16:46:30 GMT
Last-Modified: Sat, 09 May 2015 15:54:18 GMT
Server: ECS (mdw/1399)
Content-Length: 94
Connection: close

<html><head><title>edgecastcdn.net</title></head><body><h1>edgecastcdn.net</h1></body></html>

Finished WebClient test

--------------------------------

Hmm, this is promising: When I tried to use
client.print("Host: pongtester.herokuapp.com");,
... I got this back

NOTE THAT YOU DIDN'T USE "PRINTLN", ALSO NOTE THAT YOU SHOULD'VE ACTUALLY BEEN
CONNECTING TO WWW.EXAMPLE.COM STILL, AS FAR AS I CAN TELL...

Note that when using client.println("Host: pongtester.herokuapp.com");, with the "ln",
I got nothing at all (could not make TCP connection):


---------------------------
SparkFun CC3000 - WebClient
---------------------------
CC3000 initialization complete
Connecting to SSID: LolaDog
IP Address: 192.168.0.20
Performing HTTP GET of: www.example.com

HTTP/1.1 404 Not Found
Content-Type: text/html
Date: Sat, 09 May 2015 21:19:04 GMT
Server: ECS (mdw/1275)
Content-Length: 345
Connection: close

<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<title>404 - Not Found</title>
	</head>
	<body>
		<h1>404 - Not Found</h1>
	</body>
</html>

Finished WebClient test

--------------------------------

OK, also promising. Using pongtester.herokuapp.com for both:

char server[] = "pongtester.herokuapp.com";

... and:

#define HOST "pongtester.herokuapp.com"

... I get another 404 Not Found.

So why does entering the same thing as a GET in postman return my app?

Is this just a matter of needing a delay?

Mabye... I also needed to be seeking a page that actually existed... not index.html,
but rather just "/"... and... SUCCESS!

Here's the complete heroku log from my successfull attempt:

2015-05-11T02:32:37.785257+00:00 heroku[router]: at=info method=GET path="/" host=pongtester.herokuapp.com request_id=9b6d5dbb-950b-4eab-8db7-473cd4bdf254 fwd="75.166.74.55" dyno=web.1 connect=1ms service=15ms status=200 bytes=2903
2015-05-11T02:32:37.779953+00:00 app[web.1]: Started GET "/" for 75.166.74.55 at 2015-05-11 02:32:37 +0000
2015-05-11T02:32:37.788165+00:00 app[web.1]:   Rendered led/index.html.erb within layouts/application (0.7ms)
2015-05-11T02:32:37.786120+00:00 app[web.1]: Processing by LedController#index as HTML
2015-05-11T02:32:37.789421+00:00 app[web.1]: Completed 200 OK in 3ms (Views: 2.8ms | ActiveRecord: 0.0ms)

------------------------------------------

This wasn't working for me:

<script type="text/javascript">
var xhr = new XMLHttpRequest();


xhr.onreadystatechange=function() {
  if (this.readyState === 4 && this.status === 200)
    {
    document.getElementById("myDiv").innerHTML="hooptydoo";
    }
  }
xhr.open("GET", "/numberup", true);
xhr.send();
}
</script>

<div id="myDiv"><h2>Let AJAX change this text</h2></div>
<button type="button" onclick="loadXMLDoc()">Change Content</button>

------------------------------------------



--------------------------------

This was in the Maybe view:

<!DOCTYPE html>
<html>
<head>
  <title>Arduino Web Page</title>
  <script>
  function GetSwitchState()
  {
    nocache = "&nocache=" + Math.random() * 1000000
    var request =new XMLHttpRequest
    request.onreadystatechange = function()
    {
      if (this.readyState === 4) {
        if (this.status === 200) {
          if (this.responseText != null) {
            document.getElementbyId("switch_txt").innerHTML = this.responseText;

          }
        }
      }
    }
    request.open("GET", "ajax_switch" + nocache, true);
    request.send(null);
    setTimeout("GetSwitchState()", 1000)
  }
  </script>
</head>
<body onload="GetSwitchState()">
  <h1>Arduino AJAX Switch Status</h1>
  <p id="switch_text">Switch state: Not requested...</p>
</body>
</html>
